---
title: "p8105_hw6_eih2108"
author: "Ekaterina Hofrenning"
date: '2023-11-27'
output: html_document
---

```{r, message = F, warning = F, echo=FALSE}
library(tidyverse)
library(rnoaa)
```


# Problem 2

The boostrap is helpful when you’d like to perform inference for a parameter / value / summary that doesn’t have an easy-to-write-down distribution in the usual repeated sampling framework. We’ll focus on a simple linear regression with tmax as the response with tmin and prcp as the predictors, and are interested in the distribution of two quantities estimated from these data:

- r^ 2
- log(b1*b2)

Use 5000 bootstrap samples and, for each bootstrap sample, produce estimates of these two quantities. Plot the distribution of your estimates, and describe these in words. Using the 5000 bootstrap estimates, identify the 2.5% and 97.5% quantiles to provide a 95% confidence interval for r^2 and log(b1*b2).


```{r}
# read data
weather_df = 
  rnoaa::meteo_pull_monitors(
    c("USW00094728"),
    var = c("PRCP", "TMIN", "TMAX"), 
    date_min = "2022-01-01",
    date_max = "2022-12-31") %>%
  mutate(
    name = recode(id, USW00094728 = "CentralPark_NY"),
    tmin = tmin / 10,
    tmax = tmax / 10) %>%
  select(name, id, everything())
```

```{r}
# run the bootstraps
bootstrap_df =
  weather_df %>%
  modelr::bootstrap(n = 100) %>%
  mutate(
    models = map(strap, \(df) lm(tmax ~ tmin + prcp, data = df)),
    results = map(models, broom::tidy),
    rsquared = map(models, broom::glance)) %>%
  select(results, rsquared) %>% unnest(rsquared) %>%
  select(results, r.squared) %>% unnest(results) %>%
  select(term, estimate, r.squared) 
```

```{r}
# make R^2 plot
bootstrap_df %>%
  filter(term == "(Intercept)") %>%
  ggplot(aes(x = r.squared)) +
  geom_density()
```

The distribution of r-squared values has a left skew and is centered near .92.

```{r}
# plot log(b1*b2)
bootstrap_df %>%
  pivot_wider(names_from = term, values_from = estimate) %>% 
  rename(beta_1 = tmin, 
         beta_2 = prcp) %>% 
  mutate(log_b1_b2 = log(beta_1 * beta_2)) %>% 
  ggplot(aes(x = log_b1_b2)) + 
  geom_density()
```

The distribution of log(b0*b1) values has a right skew and a bit of a shoulder. It's centered around 1.09.


- can't take log of negative numbers (log b1 b2). Report how many were NAs. Then say "Of the non-NAs, the 95 and 25 CI were __". 

*Confidence intervals:*

```{r}
# CI for R^2
r_squared = 
  bootstrap_df %>%
  filter(term == "(Intercept)") %>%
  select(r.squared) %>%
  summarize(ci_lower = quantile(r.squared, 0.025), 
            ci_upper = quantile(r.squared, 0.975))

# CI for log(b1*b2)


```







